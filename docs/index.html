<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="Jsign : Pure Java implementation of Microsoft Authenticode for signing Windows executable files, Microsoft Installers (MSI), Cabinet files (CAB), Catalog files (CAT) and scripts (PowerShell, VBScript, JScript, WSF)" />
    <meta name="google-site-verification" content="p912kgAnTBOzVbswrU43k3FXUbPnxLHdeW6xsVcq1uU" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <script src="scripts/prettify/run_prettify.js"></script>
    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Jsign - Authenticode signing in Java</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/ebourg/jsign">View on GitHub</a>

          <h1 id="project_title">Jsign</h1>
          <h2 id="project_tagline">Java implementation of Microsoft Authenticode <br class="desktop-only">for signing Windows executable files, installers and scripts</h2>

            <section id="downloads">
              <a class="zip_download_link" href="#files">Download Jsign</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">


<p>Jsign is a Java implementation of Microsoft Authenticode that lets you sign
and timestamp executable files for Windows, Microsoft Installers (MSI), Cabinet files (CAB),
Catalog files (CAT) and scripts (PowerShell, VBScript, JScript, WSF). Jsign is platform
independent and provides an alternative to native tools like <em>signcode/signtool</em>
on Windows or the Mono development tools on Unix systems.</p>

<p>Jsign comes as an easy to use task/plugin for the main build systems (Maven,
Gradle, Ant). It's especially suitable for signing executable wrappers and installers
generated by tools like <a href="http://nsis.sourceforge.net">NSIS</a>,
<a href="https://wiki.gnome.org/msitools">msitools</a>,
<a href="https://www.ej-technologies.com/products/install4j/overview.html">install4j</a>,
<a href="https://www.ej-technologies.com/download/exe4j/files">exe4j</a>
or <a href="http://launch4j.sourceforge.net">launch4j</a>. Jsign can also be used
programmatically or standalone as a command line tool.</p>

<p>Jsign is free to use and licensed under the Apache License version 2.0.</p>


<h3>Features</h3>

<ul>
  <li>Platform independent signing of Windows executables, DLLs, Microsoft Installers (MSI), Cabinet files (CAB), Catalog files (CAT) and scripts (PowerShell, VBScript, JScript, WSF)</li>
  <li>Timestamping with retries and fallback on alternative servers (RFC 3161 and Authenticode protocols supported)</li>
  <li>Supports multiple signatures per file, for all file types</li>
  <li>Extracts and embeds detached signatures to support <a href="https://reproducible-builds.org/docs/embedded-signatures/">reproducible builds</a></li>
  <li>Hashing algorithms: MD5, SHA-1, SHA-256, SHA-384 and SHA-512</li>
  <li>Keystores supported:
    <ul>
      <li>PKCS#12, JKS and JCEKS files</li>
      <li>PKCS#11 hardware tokens (<a href="https://www.yubico.com">YubiKey</a>, <a href="https://www.nitrokey.com">Nitrokey</a>, etc)</li>
      <li>Cloud key management systems (<a href="https://aws.amazon.com/kms/">AWS KMS</a>, <a href="https://azure.microsoft.com/services/key-vault/">Azure Key Vault</a>, <a href="https://one.digicert.com">DigiCert ONE</a>, <a href="https://cloud.google.com/security-key-management">Google Cloud KMS</a>, <a href="https://www.ssl.com/esigner/">SSL.com eSigner</a>, <a href="https://www.vaultproject.io">HashiCorp Vault</a>)</li>
    </ul>
  <li>Private key formats: PVK and PEM (PKCS#1 and PKCS#8), encrypted or not</li>
  <li>Certificates: PKCS#7 in PEM and DER format</li>
  <li>Build tools integration (<a href="#maven">Maven</a>, <a href="#gradle">Gradle</a>, <a href="#ant">Ant</a>)</li>
  <li>Command line signing tool</li>
  <li>Authenticode signing API (<a href="https://javadoc.io/doc/net.jsign/jsign-core">Javadoc</a>)</li>
</ul>


<h3 id="ant">Ant Task</h3>

<p>Here is an example showing how the signing works with Ant, using a Java keystore:</p>

<pre class="prettyprint lang-xml">
 &lt;taskdef name="jsign" classname="net.jsign.JsignTask" classpath="jsign-4.2.jar"/>

 &lt;jsign file="application.exe"
        name="My Application"
        url="http://www.example.com"
        keystore="keystore.jks"
        alias="test"
        storepass="password"
        tsaurl="http://timestamp.sectigo.com"/>
</pre>

<br>

<p>Another example with <code>SPC</code> and <code>PVK</code> files commonly used with <code>signcode.exe</code>:</p>

<pre class="prettyprint lang-xml">
 &lt;jsign file="application.exe"
        certfile="certificate.spc"
        keyfile="key.pvk"
        keypass="password"
        tsaurl="http://timestamp.digicert.com"/>
</pre>

<br>

<p>The task also accepts a fileset to sign multiple files:</p>

<pre class="prettyprint lang-xml">
 &lt;jsign keystore="keystore.p12"
        alias="test"
        storepass="password">
   &ltfileset dir="build/binaries" includes="*.exe"/>
 &lt;/jsign>
</pre>

<br><br>

<h4 class="mobile-only">Attributes</h4>

<table style="border-collapse: collapse; width: 100%">
  <thead>
    <tr>
      <th>Attribute</th>
      <th>Description</th>
      <th align="center" width="25%">Required</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="attribute">file</td>
      <td class="description">
          The file to be signed. The supported files are Windows executables (EXE), DLLs, Microsoft Installers (MSI),
          Cabinet files (CAB), Catalog files (CAT) and scripts (PowerShell, VBScript, JScript, WSF)</td>
      <td class="required">Yes, unless a fileset is specified.</td>
    </tr>
    <tr>
      <td class="attribute">name</td>
      <td class="description">The name of the application</td>
      <td class="required">No</td>
    </tr>
    <tr>
      <td class="attribute">url</td>
      <td class="description">The URL of the application</td>
      <td class="required">No</td>
    </tr>
    <tr>
      <td class="attribute">keystore</td>
      <td class="description">
          The keystore file, the <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/security/p11guide.html#Config">SunPKCS11 configuration file</a>
          or the cloud keystore name.
      </td>
      <td class="required">Yes, unless <code>certfile</code> and <code>keyfile</code> are specified.</td>
    </tr>
    <tr>
      <td class="attribute">storepass</td>
      <td class="description">
        The password to open the keystore. The password can be loaded from a file by using the <code>file:</code> prefix
        followed by the path of the file, or from an environment variable by using the <code>env:</code> prefix followed
        by the name of the variable.
      </td>
      <td class="required">No</td>
    </tr>
    <tr>
      <td class="attribute">storetype</td>
      <td class="description">
        The type of the keystore:
        <ul>
          <li><code>JKS</code>: Java keystore (<code>.jks</code> files)</li>
          <li><code>JCEKS</code>: SunJCE keystore (<code>.jceks</code> files)</li>
          <li><code>PKCS12</code>: Standard PKCS#12 keystore (<code>.p12</code> or <code>.pfx</code> files)</li>
          <li><code>PKCS11</code>: PKCS#11 hardware token</li>
          <li><code>NITROKEY</code>: Nitrokey HSM</li>
          <li><code>OPENPGP</code>: OpenPGP card</li>
          <li><code>OPENSC</code>: Smart card</li>
          <li><code>YUBIKEY</code>: YubiKey security key (requires ykcs11)</li>
          <li><code>AWS</code>: AWS Key Management Service</li>
          <li><code>AZUREKEYVAULT</code>: Azure Key Vault key management system</li>
          <li><code>DIGICERTONE</code>: DigiCert ONE Secure Software Manager</li>
          <li><code>ESIGNER</code>: SSL.com eSigner</li>
          <li><code>GOOGLECLOUD</code>: Google Cloud KMS</li>
          <li><code>HASHICORPVAULT</code>: Google Cloud KMS via HashiCorp Vault</li>
        </ul>
      </td>
      <td class="required">No, automatically detected for file based keystores.</td>
    </tr>
    <tr>
      <td class="attribute">alias</td>
      <td class="description">The alias of the certificate used for signing in the keystore.</td>
      <td class="required">Yes, if <code>keystore</code> is specified and more than one alias exist</td>
    </tr>
    <tr>
      <td class="attribute">certfile</td>
      <td class="description">The file containing the PKCS#7 certificate chain (<code>.p7b</code> or <code>.spc</code> files).</td>
      <td class="required" rowspan="2">Yes, unless <code>keystore</code> is specified.</td>
    </tr>
    <tr>
      <td class="attribute">keyfile</td>
      <td class="description">
        The file containing the private key. <code>PEM</code> and <code>PVK</code> files are supported.
      </td>
    </tr>
    <tr>
      <td class="attribute">keypass</td>
      <td class="description">
        The password of the private key. When using a keystore, this parameter can be omitted if the keystore shares
        the same password. The password can be loaded from a file by using the <code>file:</code> prefix followed by
        the path of the file, or from an environment variable by using the <code>env:</code> prefix followed by the
        name of the variable.
      </td>
      <td class="required">No</td>
    </tr>
    <tr>
      <td class="attribute">alg</td>
      <td class="description">The digest algorithm (SHA-1, SHA-256, SHA-384 or SHA-512)</td>
      <td class="required">No; defaults to SHA-256</td>
    </tr>
    <tr>
      <td class="attribute">tsaurl</td>
      <td class="description">
          The URL of the timestamping authority, either RFC 3161 or Authenticode services.
          You can use for example the Sectigo (http://timestamp.sectigo.com)
          or the DigiCert (http://timestamp.digicert.com) services.<br>
          Several URLs separated by a comma can be specified to fallback on alternative servers.
      </td>
      <td class="required">No</td>
    </tr>
    <tr>
      <td class="attribute">tsmode</td>
      <td class="description">The timestamping mode (RFC3161 or Authenticode)</td>
      <td class="required">No; defaults to Authenticode</td>
    </tr>
    <tr>
      <td class="attribute">tsretries</td>
      <td class="description">The number of retries for timestamping</td>
      <td class="required">No; defaults to 3</td>
    </tr>
    <tr>
      <td class="attribute">tsretrywait</td>
      <td class="description">The number of seconds to wait between timestamping retries</td>
      <td class="required">No; defaults to 10 seconds</td>
    </tr>
    <tr>
      <td class="attribute">replace</td>
      <td class="description">Tells if previous signatures should be replaced.</td>
      <td class="required">No; defaults to "false"</td>
    </tr>
    <tr>
      <td class="attribute">encoding</td>
      <td class="description">The encoding of the script to be signed (if it doesn't contain a byte order mark).</td>
      <td class="required">No; defaults to "UTF-8"</td>
    </tr>
    <tr>
      <td class="attribute">detached</td>
      <td class="description">
        Tells if a detached signature should be generated or reused. The detached signature
        is a file in the same directory using the name of the file signed with the <code>.sig</code>
        suffix added (for example <code>application.exe.sig</code>).
        <ul>
          <li>If the signature doesn't exist, the file is signed as usual and the detached signature is generated.</li>
          <li>If the signature exists it is attached to the file, replacing any existing signature (in this case
              the private key isn't used for signing and no timestamping is performed).</li>
        </ul>
      </td>
      <td class="required">No; defaults to "false"</td>
    </tr>
  </tbody>
</table>


<h3 id="maven">Maven plugin</h3>

<p>Here is an example showing how the signing works with Maven. The parameters
are the same as those described above for the Ant task. The execution is bound
by default to the <code>package</code> phase.</p>

<pre class="prettyprint lang-xml">
    &lt;build>
      &lt;plugins>
        &lt;plugin>
          &lt;groupId>net.jsign&lt;/groupId>
          &lt;artifactId>jsign-maven-plugin&lt;/artifactId>
          &lt;version>4.2&lt;/version>
          &lt;executions>
            &lt;execution>
              &lt;goals>
                &lt;goal>sign&lt;/goal>
              &lt;/goals>
              &lt;configuration>
                &lt;file>application.exe&lt;/file>
                &lt;name>My Application&lt;/name>
                &lt;url>http://www.example.com&lt;/url>
                &lt;keystore>keystore.jks&lt;/keystore>
                &lt;alias>test&lt;/alias>
                &lt;storepass>password&lt;/storepass>
              &lt;/configuration>
            &lt;/execution>
          &lt;/executions>
        &lt;/plugin>
      &lt;/plugins>
    &lt;/build>
</pre>

<p>It's possible to sign multiple files by using a <code>fileset</code> element instead of <code>file</code>:</p>

<pre class="prettyprint lang-xml">
              ...
              &lt;configuration>
                &lt;fileset>
                  &lt;directory>target&lt;/directory>
                  &lt;includes>
                    &lt;include>*.exe&lt;/include>
                  &lt;/includes>
                &lt;/fileset>
                &lt;keystore>keystore.jks&lt;/keystore>
                &lt;alias>test&lt;/alias>
                &lt;storepass>password&lt;/storepass>
              &lt;/configuration>
              ...
</pre>

<p>The value of the <code>storepass</code> and <code>keypass</code> elements can be encrypted using the
<a href="https://maven.apache.org/guides/mini/guide-encryption.html">Maven master password</a>:</p>

<pre class="prettyprint lang-xml">
              &lt;configuration>
                &lt;file>application.exe&lt;/file>
                &lt;keystore>keystore.jks&lt;/keystore>
                &lt;storepass>{COQLCE6DU6GtcS5P=}&lt;/storepass>
              &lt;/configuration>
</pre>

<p>The <code>storepass</code> and <code>keypass</code> elements may also reference a password defined
in the <a href="https://maven.apache.org/settings.html">Maven settings file</a>.</p>

<p>In <code> ${user.home}/.m2/settings.xml</code> a server is defined with the password of the keystore:</p>

<pre class="prettyprint lang-xml">
  &lt;settings xmlns="http://maven.apache.org/SETTINGS/1.0.0">
    ...
    &lt;servers>
      &lt;server>
        &lt;id>keystore&lt;/id>
        &lt;password>password&lt;/password>
      &lt;/server>
    &lt;/servers>
    ...
  &lt;/settings>
</pre>

<p>And in the Maven project file, the password element references the server id prefixed with <code>mvn:</code>:</p>

<pre class="prettyprint lang-xml">
              &lt;configuration>
                &lt;file>application.exe&lt;/file>
                &lt;keystore>keystore.jks&lt;/keystore>
                &lt;storepass>mvn:keystore&lt;/storepass>
              &lt;/configuration>
</pre>

<h3 id="gradle">Gradle plugin</h3>

<p>Here is an example showing how to use Jsign with Gradle. The parameters
are the same as those described above for the Ant task.</p>

<p>With the Groovy syntax:</p>

<pre class="prettyprint lang-groovy">
    buildscript {
        dependencies {
            classpath 'net.jsign:jsign-gradle-plugin:4.2'
        }
    }
    
    apply plugin: 'net.jsign'
    
    task sign {
        doLast {
            jsign(file      : 'application.exe',
                  name      : 'My Application',
                  url       : 'http://www.example.com',
                  keystore  : 'keystore.p12',
                  alias     : 'test',
                  storepass : 'secret',
                  tsaurl    : 'http://timestamp.sectigo.com')
        }
    }
</pre>

<p>With the Kotlin syntax:</p>

<pre class="prettyprint lang-kotlin">
    buildscript {
        dependencies {
            classpath("net.jsign:jsign-gradle-plugin:4.2")
        }
    }
    
    apply(plugin = "net.jsign")
    
    task("sign") {
        doLast {
            val jsign = project.extensions.getByName("jsign") as groovy.lang.Closure<*>
            jsign("file"      to "application.exe",
                  "name"      to "My Application",
                  "url"       to "http://www.example.com",
                  "keystore"  to "keystore.p12",
                  "alias"     to "test",
                  "storepass" to "secret",
                  "tsaurl"    to "http://timestamp.sectigo.com")
        }
    }
</pre>

<h3>Command Line Tool</h3>

<p>Jsign can also be used as a command line tool. A <a href="https://github.com/ebourg/jsign/releases/download/4.2/jsign_4.2_all.deb">Debian package</a>
and a <a href="https://github.com/ebourg/jsign/releases/download/4.2/jsign-4.2-1.noarch.rpm">RPM package</a>
are provided to install it easily on most Linux distributions. On these systems the command line is invoked with:</p>

<pre> jsign [OPTIONS] [FILE]...</pre>

<p>On other systems the command line is invoked by running the jar with:</p>
    
<pre> java -jar jsign-4.2.jar [OPTIONS] [FILE]...</pre>
    
<p>The parameters expected are the same as those used by the Ant task:</p>

<pre>
  usage: jsign [OPTIONS] [FILE]...
  Sign and timestamp Windows executable files, Microsoft Installers (MSI), Cabinet
  files (CAB), Catalog files (CAT) or scripts (PowerShell, VBScript, JScript, WSF).
  
  -s,--keystore &lt;FILE>       The keystore file, the SunPKCS11 configuration file or
                             the cloud keystore name
     --storepass &lt;PASSWORD>  The password to open the keystore
     --storetype &lt;TYPE>      The type of the keystore:
                             - JKS: Java keystore (.jks files)
                             - JCEKS: SunJCE keystore (.jceks files)
                             - PKCS12: Standard PKCS#12 keystore (.p12 or .pfx files)
                             - PKCS11: PKCS#11 hardware token
                             - NITROKEY: Nitrokey HSM
                             - OPENPGP: OpenPGP card
                             - OPENSC: Smart card
                             - YUBIKEY: YubiKey security key
                             - AWS: AWS Key Management Service
                             - AZUREKEYVAULT: Azure Key Vault key management system
                             - DIGICERTONE: DigiCert ONE Secure Software Manager
                             - ESIGNER: SSL.com eSigner
                             - GOOGLECLOUD: Google Cloud KMS
                             - HASHICORPVAULT: Google Cloud KMS via HashiCorp Vault
  -a,--alias &lt;NAME>          The alias of the certificate used for signing in the keystore.
     --keypass &lt;PASSWORD>    The password of the private key. When using a keystore,
                             this parameter can be omitted if the keystore shares the
                             same password.
     --keyfile &lt;FILE>        The file containing the private key (supports PEM &amp; PVK files)
  -c,--certfile &lt;FILE>       The file containing the PKCS#7 certificate chain
                             (.p7b or .spc files).
  -d,--alg &lt;ALGORITHM>       The digest algorithm (SHA-1, SHA-256, SHA-384 or SHA-512)
  -t,--tsaurl &lt;URL>          The URL of the timestamping authority. Several URLs separated
                             by a comma can be specified to fallback on alternative servers
  -m,--tsmode &lt;MODE>         The timestamping mode (RFC3161 or Authenticode)
  -r,--tsretries &lt;NUMBER>    The number of retries for timestamping
  -w,--tsretrywait &lt;SECONDS> The number of seconds to wait between timestamping retries
  -n,--name &lt;NAME>           The name of the application
  -u,--url &lt;URL>             The URL of the application
     --proxyUrl &lt;URL>        The URL of the HTTP proxy
     --proxyUser &lt;NAME>      The user for the HTTP proxy. If an user is needed.
     --proxyPass &lt;PASSWORD>  The password for the HTTP proxy user. If an user is needed.
     --replace               Tells if previous signatures should be replaced.
  -e,--encoding &lt;ENCODING>   The encoding of the script to be signed (UTF-8 by default,
                             or the encoding specified by the byte order mark if there is one)
     --detached              Tells if a detached signature should be generated or reused.
  -h,--help                  Print the help
</pre>

<h4>Example using a Java keystore:</h4>

<pre>
 jsign --keystore keystore.jks --alias test --storepass password \
       --tsaurl http://timestamp.sectigo.com application.exe
</pre>

<h4>Example using SPC/PVK files:</h4>

<pre>
 jsign --certfile certificate.spc --keyfile key.pvk --keypass password application.exe
</pre>

<h4 id="example-yubikey">Example using a YubiKey:</h4>

<p>When using a Yubikey, the alias is required only if the device contains more than one certificate.
The certificate is specified by its name (typically <em>X.509 Certificate for Digital Signature</em> for
the slot 9c, or <em>X.509 Certificate for PIV Authentication</em> for the slot 9a). The ykcs11 library
from the <a href="https://developers.yubico.com/yubico-piv-tool/">Yubico PIV Tool</a> must
be installed on the system at the default location.</p>

<pre>
 jsign --storetype YUBIKEY --certfile full-chain.pem --storepass 123456 application.exe
</pre>

<h4 id="example-nitrokey">Example using a Nitrokey HSM:</h4>

<p>Signing with a Nitrokey HSM requires the installation of <a href="https://github.com/OpenSC/OpenSC">OpenSC</a>.</p>

<pre>
 jsign --storetype NITROKEY --certfile full-chain.pem --storepass 123456 \
       --alias test application.exe
</pre>

<p>Other Nitrokeys based on the OpenPGP card standard are also supported with this storetype, but an X.509 certificate
must be imported into the Nitrokey (using the gnupg <a href="https://www.gnupg.org/documentation/manuals/gnupg/gpg_002dcard.html">writecert</a>
command). Keys without certificates are ignored. Alternatively, the OPENPGP storetype can also be used, it doesn't
require OpenSC and any key can be used by providing an external certificate.</p>

<h4 id="example-smart-card">Example using a smart card:</h4>

<p>Signing with a smart card requires the installation of <a href="https://github.com/OpenSC/OpenSC">OpenSC</a>.</p>

<pre>
 jsign --storetype OPENSC --certfile full-chain.pem --storepass 123456 \
       --alias test application.exe
</pre>

<p>If multiple devices are connected, the <code>keystore</code> parameter can be used to specify
the name of the one to use.</p>

<h4 id="example-openpgp">Example using an OpenPGP card:</h4>

<p>OpenPGP cards contain up to 3 keys, one for signing, one for encryption, and one for authentication. All of them
can be used for code signing (except encryption keys based on an elliptic curve). The alias to select the key is either,
<code>SIGNATURE</code>, <code>ENCRYPTION</code> or <code>AUTHENTICATION</code>. The OPENPGP storetype can be used with
a Nitrokey (non-HSM models) or a Yubikey.</p>

<pre>
 jsign --storetype OPENPGP --certfile full-chain.pem --storepass 123456 \
       --alias SIGNATURE application.exe
</pre>

<p>X.509 certificates stored on the card are automatically used, and the <code>certfile</code> parameter is only
required if the certificate chain contains an intermediate certificate.</p>

<h4 id="example-awskms">Example using AWS Key Management Service:</h4>

<p><a href="https://aws.amazon.com/kms/">AWS Key Management Service</a> (KMS) stores only the private key,
the certificate must be provided separately. The <code>keystore</code> parameter references the AWS region.
The AWS access key, secret key, and optionally the session token, are concatenated
and used as the <code>storepass</code> parameter; if the latter is not provided, the executable is assumed to be running on an AWS EC2 instance,
and the <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html">IMDSv2</a> service
is queried to obtain temporary credentials based on the instance profile. In any case, the credentials must allow the following actions:
<code>kms:ListKeys</code>, <code>kms:DescribeKey</code>, and <code>kms:Sign</code>.
The <code>alias</code> parameter can specify either the key id or an alias.</p>

<pre>
 jsign --storetype AWS --keystore eu-west-3 \
       --storepass "&lt;access-key&gt;|&lt;secret-key&gt;|&lt;session-token&gt;" \
       --alias 12345678-abcd-1234-cdef-1234567890ab \
       --certfile full-chain.pem application.exe
</pre>

<h4 id="example-azurekeyvault">Example using Azure Key Vault:</h4>

<p>Certificates and keys stored in the <a href="https://azure.microsoft.com/services/key-vault/">Azure Key Vault</a>
key management system can be used with:</p>

<pre>
 jsign --storetype AZUREKEYVAULT --keystore vaultname --alias test \
       --storepass &lt;api-access-token&gt; application.exe
</pre>

<h4 id="example-digicertone">Example using DigiCert ONE:</h4>

<p>Certificates and keys stored in the <a href="https://one.digicert.com">DigiCert ONE</a> Secure Software Manager
can be used directly without installing the DigiCert client tools. It requires an API key and a PKCS#12 keystore holding
a client certificate for the authentication.</p>

<pre>
 jsign --storetype DIGICERTONE --alias test \
       --storepass "&lt;api-key&gt;|/path/to/Certificate_pkcs12.p12|&lt;password&gt;" application.exe
</pre>

<h4 id="example-sslcom-esigner">Example using SSL.com eSigner:</h4>

<p>When signing with the <a href="https://www.ssl.com/esigner/">SSL.com eSigner</a> service, the SSL.com username and
password are used as the keystore password, and the base64 encoded TOTP secret is used as the key password:</p>

<pre>
 jsign --storetype ESIGNER --storepass "&lt;username&gt;|&lt;password&gt;" \
       --alias 8b072e22-7685-4771-b5c6-48e46614915f \
       --keypass &lt;totp-secret&gt; application.exe
</pre>

<p>SSL.com provides a sandbox environment, to use a test certificate simply add the parameter
<code>--keystore https://cs-try.ssl.com</code>.</p>

<h4 id="example-googlecloud">Example using Google Cloud KMS:</h4>

<p>Google Cloud KMS stores only the private key, the certificate must be provided separately. The keystore parameter
references the path of the keyring. The alias can specify either the full path of the key, or only the short name. If
the version is omitted the most recent one will be picked automatically.</p>

<pre>
 jsign --storetype GOOGLECLOUD --storepass &lt;api-access-token&gt; \
       --keystore projects/first-rain-123/locations/global/keyRings/mykeyring \
       --alias test --certfile full-chain.pem application.exe
</pre>

<h4 id="example-hashicorpvault">Example using Google Cloud KMS via HashiCorp Vault:</h4>

<p>Google Cloud KMS stores only the private key, the certificate must be provided separately. The keystore parameter
references the URL of the HashiCorp Vault secrets engine, consisting of the Vault server URL, the API version v1 and
the secrets engine path. The alias specifies the name of the key in Vault and the key version in Google Cloud separated
by a colon character.</p>

<pre>
 jsign --storetype HASHICORPVAULT --storepass &lt;vault-token&gt; \
       --keystore https://vault.example.com/v1/gcpkms \
       --alias test:1 --certfile full-chain.pem application.exe
</pre>


<h3>API</h3>

<p>Jsign also provides a simple API for signing files and can be embedded in another application.</p>

<p>Simply add this dependency to the project:<p>

<pre class="prettyprint lang-xml">
    &lt;dependency>
      &lt;groupId>net.jsign&lt;/groupId>
      &lt;artifactId>jsign-core&lt;/artifactId>
      &lt;version>4.2&lt;/version>
    &lt;/dependency>
</pre>

<p>and then use the <code>AuthenticodeSigner</code> class like this:</p>

<pre class="prettyprint lang-java">
 KeyStore keystore = KeyStoreUtils.load(new File("keystore.p12"), "PKCS12", "password", null);

 AuthenticodeSigner signer = new AuthenticodeSigner(keystore, "test", "secret");
 signer.withProgramName("My Application")
       .withProgramURL("http://www.example.com")
       .withTimestamping(true)
       .withTimestampingAuthority("http://timestamp.sectigo.com");

 try (Signable file = Signable.of(new File("application.exe"))) {
     signer.sign(file);
 }
</pre>

<p>See the <a href="https://javadoc.io/doc/net.jsign/jsign-core">Javadoc</a> for more details about the API.</p>


<h3 id="files">Downloads</h3>

<ul>
  <li><a href="https://github.com/ebourg/jsign/releases/download/4.2/jsign_4.2_all.deb">jsign_4.2_all.deb</a> - Jsign command line tool for Debian/Ubuntu</li>
  <li><a href="https://github.com/ebourg/jsign/releases/download/4.2/jsign-4.2-1.noarch.rpm">jsign-4.2-1.noarch.rpm</a> - Jsign command line tool for RedHat/Fedora/CentOS</li>
  <li><a href="https://github.com/ebourg/jsign/releases/download/4.2/jsign-4.2.jar">jsign-4.2.jar</a> - Jsign Ant Task</li>
</ul>


<h3>Credits</h3>

<p>Jsign leverages the cryptography API developed by the <a href="http://www.bouncycastle.org">Bouncy Castle</a> project.<br>
PVK parsing is based on the <a href="https://web.archive.org/web/20170810033553/http://www.drh-consultancy.demon.co.uk/pvk.html">pvktool</a> by Stephen N Henson.<br>
MSI signing was possible thanks to the work done by the <a href="https://github.com/mtrojnar/osslsigncode">osslsigncode</a> and <a href="https://poi.apache.org/">Apache POI</a> projects.</p>

<p>Jsign includes contributions from Emmanuel Bourg, Florent Daigniere, Michael Szediwy, Michael Peterson, Markus Kilås, Erwin Tratar, Björn Kautler, Joseph Lee and Maria Merkel.</p>

<h3>Contact</h3>

<p>Emmanuel Bourg (<a href="mailto:ebourg@apache.org">ebourg@apache.org</a>, <a href="https://twitter.com/smanux">@smanux</a>)</p>


      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Jsign maintained by <a href="https://github.com/ebourg">ebourg</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

  </body>
</html>
